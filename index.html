<input id="fileItem" type="file">

<script>
    // We use a worker because it is asynchronous, which means the ui doesn't freeze while parsing
    const worker = new Worker('parser.js', {type: 'module'});

    // output messages from worker
    worker.onmessage = (event) => {
        if (event.data.hasOwnProperty('percentage')) {
            console.debug(`percentage: ${event.data.percentage}`)
        } else if (event.data.hasOwnProperty('availableMessages')) {
            console.debug('Available message types:')
            console.debug(event.data.availableMessages)
        } else if (event.data.hasOwnProperty('metadata')) {
            console.debug('got metadata:')
            console.debug(event.data.metadata)
        } else if (event.data.hasOwnProperty('messages')) {
            console.debug('got messages')
            console.debug(event.data.messages)
        } else if (event.data.hasOwnProperty('messageType')) {
            console.debug(`got list of ${event.data.messageType}:`)
            console.debug(event.data.messageList)
        } else if (event.data.hasOwnProperty('files')) {
            console.debug('got files:')
            console.debug(event.data.files)
        } else if (event.data.hasOwnProperty('messagesDoneLoading')) {
            console.debug('messages finished loading')
        }
    }


    // File input
    const readFile = e => {
        const file = e.target.files[0]
        let reader = new FileReader()
        reader.onload = function (e) {
            let arrayBuffer = new Uint8Array(reader.result)
            console.debug(arrayBuffer)
            let data = reader.result
            worker.postMessage({
                action: 'parse',
                file: data,
            })
        }

        reader.readAsArrayBuffer(file)
    // end of file input
    }
    document.querySelector("#fileItem").onchange = readFile
</script>